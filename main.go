package main

import (
	//"bytes"
	"cbjson"
	//"encoding/json"
	"flag"
	"fmt"
	cb "github.com/clearblade/Go-SDK"
	//"io/ioutil"
	"os"
	"sync"
)

type Stmt interface {
	run(ctx map[string]interface{}, args []interface{}) (interface{}, error)
	help() string
}

const (
	SceneTestEnvVar = "SCENETEST_PATH"
)

var (
	MsgAddr      string
	PlatformAddr string
	ScriptFile   string
	SetupFile    string
	TeardownFile string
	InfoFile     string
	//JustParse      bool
	GetSomeHelp    bool
	SceneRoot      string
	FileSearchPath []string
	Login          bool
	ShutUp         bool
)

var (
	funcMap    = map[string]Stmt{}
	scriptVars = map[string]interface{}{}
	globals    = map[string]interface{}{}
	globalLock = sync.RWMutex{}
	printLock  = sync.Mutex{}
)

func init() {
	flag.StringVar(&MsgAddr, "messaging-url", "", "Msg service location")
	flag.StringVar(&PlatformAddr, "platform-url", "", "Platform location")
	//flag.StringVar(&ScriptFile, "run", "", "Script file to execute")
	//flag.StringVar(&SetupFile, "setup", "", "File to setup system(s)")
	//flag.StringVar(&TeardownFile, "teardown", "", "File that tears you up")
	flag.StringVar(&InfoFile, "info", "", "File generated by setup to be used by the tests")
	flag.BoolVar(&GetSomeHelp, "help", false, "Print out a help string for all statements")
	//flag.BoolVar(&JustParse, "parse", false, "Just parse everything and don't execute")
	flag.BoolVar(&Login, "login", true, "login to the clearblade system as specified by cmd line args to TestSystemInfo.json")
	flag.BoolVar(&ShutUp, "silent", false, "Shut Up!")

	scriptVars["roles"] = map[string]interface{}{}
	scriptVars["users"] = map[string]interface{}{}
	scriptVars["collections"] = map[string]interface{}{}
	scriptVars["items"] = map[string]interface{}{}
	scriptVars["codeServices"] = map[string]interface{}{}
	scriptVars["codeLibraries"] = map[string]interface{}{}
	scriptVars["triggers"] = map[string]interface{}{}
	scriptVars["timers"] = map[string]interface{}{}
}

func extractCommand() (string, error) {
	if len(os.Args) < 2 {
		return "", fmt.Errorf("Missing command")
	}
	rval := os.Args[1]
	os.Args = append(os.Args[:1], os.Args[2:]...)
	return rval, nil
}

func getFileOrDie() string {
	args := flag.Args()
	if len(args) != 1 {
		fmt.Printf("Missing file argument\n")
		os.Exit(1)
	}
	return args[0]
}

func mustHave(stuff ...string) {
	if len(stuff)%2 != 0 {
		fatal("Internal error: mustHave takes an even number of args\n")
	}
	for i := 0; i < len(stuff); i += 2 {
		key, val := stuff[i], stuff[i+1]
		if val == "" {
			fatal(fmt.Sprintf("Missing '%s' argument\n", key))
		}
	}
}

func main() {
	theCommand, err := extractCommand()
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	flag.Parse()
	cb.CB_ADDR = PlatformAddr
	cb.CB_MSG_ADDR = MsgAddr
	setupSceneRoot()
	setupFileSearchPath()

	if theCommand == "setup" {

		mustHave("platformUrl", PlatformAddr, "messagingUrl", MsgAddr, "info", InfoFile)
		SetupFile = getFileOrDie()
		performSetup(getJSON(SetupFile))

	} else if theCommand == "run" {

		mustHave("info", InfoFile)
		ScriptFile = getFileOrDie()
		scriptVars = getJSON(InfoFile)
		cb.CB_ADDR = scriptVars["platformUrl"].(string)
		cb.CB_MSG_ADDR = scriptVars["messagingUrl"].(string)
		executeTestScript(getJSON(ScriptFile))
	} else if theCommand == "teardown" {
		mustHave("info", InfoFile)
		scriptVars = getJSON(InfoFile)
		cb.CB_ADDR = scriptVars["platformUrl"].(string)
		cb.CB_MSG_ADDR = scriptVars["messagingUrl"].(string)
		performTeardown()
	} else if theCommand == "help" {
		showHelp()
	} else {
		fmt.Printf("Unknown Command '%s'\n", theCommand)
		os.Exit(1)
	}
	/*
		if SetupFile != "Do Not Setup" && InfoFile != "Do Not Get Info" {
			fatal("Can't have both a setup file and an info file. I know. Confusing.")
		}
		if SetupFile != "Do Not Setup" {
			performSetup(getJSON(SetupFile))
		}
		if InfoFile != "Do Not Get Info" {
			scriptVars = getJSON(InfoFile)
			if PlatformAddr == "undefined" {
				cb.CB_ADDR = scriptVars["platformUrl"].(string)
			}
			if MsgAddr == "undefined" {
				cb.CB_MSG_ADDR = scriptVars["messagingUrl"].(string)
			}
		}
		if ScriptFile != "Do Not Run Script" {
			executeTestScript(getJSON(ScriptFile))
		}
		if TeardownFile != "Do Not Teardown" {
			performTeardown(getJSON(TeardownFile))
		}
	*/
}

func getJSON(filename string) map[string]interface{} {
	theStuff, _, err := cbjson.GetJSONFile(filename)
	if err != nil {
		goodbye(err)
	}
	return theStuff
}

func goodbye(err error) {
	myPrintf("%s\n", err.Error())
	os.Exit(1)
}

func parseProvidedFiles() {
	if SetupFile != "Do Not Setup" {
		myPrintf("Parsing %s... ", SetupFile)
		getJSON(SetupFile)
		myPrintf("ok\n")
	}
	if TeardownFile != "Do Not Teardown" {
		myPrintf("Parsing %s... ", TeardownFile)
		getJSON(TeardownFile)
		myPrintf("ok\n")
	}
	if ScriptFile != "Do Not Run Script" {
		myPrintf("Parsing %s... ", ScriptFile)
		getJSON(ScriptFile)
		myPrintf("ok\n")
	}
}

func weInTheHouse() {
	globalLock.Lock()
}

func weOuttaTheHouse() {
	globalLock.Unlock()
}

func getGlobal(name string) interface{} {
	if val, ok := globals[name]; ok {
		return val
	}
	return nil
}

func setGlobal(name string, val interface{}) {
	globals[name] = val
}

func fatalf(theFmt string, args ...interface{}) {
	myPrintf(theFmt, args...)
	os.Exit(1)
}

func myPrintf(theFmt string, args ...interface{}) {
	printLock.Lock()
	defer printLock.Unlock()
	fmt.Printf(theFmt, args...)
}

func myNestingPrintf(ctx map[string]interface{}, theFmt string, args ...interface{}) {
	duhFmt := ""
	lvl := ctx["__nestingLevel"].(int)
	for i := 0; i < lvl; i++ {
		duhFmt += "    "
	}
	myPrintf(duhFmt+theFmt, args...)
}
